{"id":"../node_modules/@teachablemachine/image/dist/teachable-mobilenet.js","dependencies":[{"name":"C:\\Users\\jeast\\Documents\\Rekordelig\\rekordalig_v1\\node_modules\\@teachablemachine\\image\\dist\\teachable-mobilenet.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\jeast\\Documents\\Rekordelig\\rekordalig_v1\\node_modules\\@teachablemachine\\image\\src\\teachable-mobilenet.ts","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\jeast\\Documents\\Rekordelig\\rekordalig_v1\\package.json","includedInParent":true,"mtime":1595816498057},{"name":"C:\\Users\\jeast\\Documents\\Rekordelig\\rekordalig_v1\\node_modules\\@teachablemachine\\image\\package.json","includedInParent":true,"mtime":1595807186102},{"name":"@tensorflow/tfjs","loc":{"line":69,"column":21},"parent":"C:\\Users\\jeast\\Documents\\Rekordelig\\rekordalig_v1\\node_modules\\@teachablemachine\\image\\dist\\teachable-mobilenet.js","resolved":"C:\\Users\\jeast\\Documents\\Rekordelig\\rekordalig_v1\\node_modules\\@tensorflow\\tfjs\\dist\\tf.esm.js"},{"name":"./utils/tf","loc":{"line":70,"column":19},"parent":"C:\\Users\\jeast\\Documents\\Rekordelig\\rekordalig_v1\\node_modules\\@teachablemachine\\image\\dist\\teachable-mobilenet.js","resolved":"C:\\Users\\jeast\\Documents\\Rekordelig\\rekordalig_v1\\node_modules\\@teachablemachine\\image\\dist\\utils\\tf.js"},{"name":"./custom-mobilenet","loc":{"line":71,"column":33},"parent":"C:\\Users\\jeast\\Documents\\Rekordelig\\rekordalig_v1\\node_modules\\@teachablemachine\\image\\dist\\teachable-mobilenet.js","resolved":"C:\\Users\\jeast\\Documents\\Rekordelig\\rekordalig_v1\\node_modules\\@teachablemachine\\image\\dist\\custom-mobilenet.js"},{"name":"seedrandom","loc":{"line":72,"column":25},"parent":"C:\\Users\\jeast\\Documents\\Rekordelig\\rekordalig_v1\\node_modules\\@teachablemachine\\image\\dist\\teachable-mobilenet.js","resolved":"C:\\Users\\jeast\\Documents\\Rekordelig\\rekordalig_v1\\node_modules\\seedrandom\\index.js"}],"generated":{"js":"\"use strict\";\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tf = require(\"@tensorflow/tfjs\");\nvar tfjs_1 = require(\"@tensorflow/tfjs\");\nvar tf_1 = require(\"./utils/tf\");\nvar custom_mobilenet_1 = require(\"./custom-mobilenet\");\nvar seedrandom = require(\"seedrandom\");\nvar VALIDATION_FRACTION = 0.15;\n// tslint:disable-next-line:no-any\nvar isTensor = function (c) {\n    return typeof c.dataId === 'object' && c.shape === 'object';\n};\n/**\n * Converts an integer into its one-hot representation and returns\n * the data as a JS Array.\n */\nfunction flatOneHot(label, numClasses) {\n    var labelOneHot = new Array(numClasses).fill(0);\n    labelOneHot[label] = 1;\n    return labelOneHot;\n}\n/**\n * Shuffle an array of Float32Array or Samples using Fisher-Yates algorithm\n * Takes an optional seed value to make shuffling predictable\n */\nfunction fisherYates(array, seed) {\n    var _a;\n    var length = array.length;\n    // need to clone array or we'd be editing original as we goo\n    var shuffled = array.slice();\n    for (var i = (length - 1); i > 0; i -= 1) {\n        var randomIndex = void 0;\n        if (seed) {\n            randomIndex = Math.floor(seed() * (i + 1));\n        }\n        else {\n            randomIndex = Math.floor(Math.random() * (i + 1));\n        }\n        _a = [shuffled[randomIndex], shuffled[i]], shuffled[i] = _a[0], shuffled[randomIndex] = _a[1];\n    }\n    return shuffled;\n}\nvar TeachableMobileNet = /** @class */ (function (_super) {\n    __extends(TeachableMobileNet, _super);\n    function TeachableMobileNet(truncated, metadata) {\n        var _this = _super.call(this, tf.sequential(), metadata) || this;\n        // private __stopTrainingReject: (error: Error) => void;\n        // Number of total samples\n        _this.totalSamples = 0;\n        // Array of all the examples collected\n        _this.examples = [];\n        // the provided model is the truncated mobilenet\n        _this.truncatedModel = truncated;\n        return _this;\n    }\n    Object.defineProperty(TeachableMobileNet.prototype, \"asSequentialModel\", {\n        get: function () {\n            return this.model;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TeachableMobileNet.prototype, \"isTrained\", {\n        /**\n         * has the teachable model been trained?\n         */\n        get: function () {\n            return !!this.model && this.model.layers && this.model.layers.length > 2;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TeachableMobileNet.prototype, \"isPrepared\", {\n        /**\n         * has the dataset been prepared with all labels and samples processed?\n         */\n        get: function () {\n            return !!this.trainDataset;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TeachableMobileNet.prototype, \"numClasses\", {\n        /**\n         * how many classes are in the dataset?\n         */\n        get: function () {\n            return this._metadata.labels.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Add a sample of data under the provided className\n     * @param className the classification this example belongs to\n     * @param sample the image / tensor that belongs in this classification\n     */\n    // public async addExample(className: number, sample: HTMLCanvasElement | tf.Tensor) {\n    TeachableMobileNet.prototype.addExample = function (className, sample) {\n        return __awaiter(this, void 0, void 0, function () {\n            var cap, example, activation;\n            return __generator(this, function (_a) {\n                cap = isTensor(sample) ? sample : tf_1.capture(sample);\n                example = this.truncatedModel.predict(cap);\n                activation = example.dataSync();\n                cap.dispose();\n                example.dispose();\n                // save samples of each class separately\n                this.examples[className].push(activation);\n                // increase our sample counter\n                this.totalSamples++;\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * Classify an input image / Tensor with your trained model. Return all results.\n     * @param image the input image / Tensor to classify against your model\n     * @param topK how many of the top results do you want? defautls to 3\n     */\n    TeachableMobileNet.prototype.predict = function (image, flipped) {\n        if (flipped === void 0) { flipped = false; }\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (!this.model) {\n                    throw new Error('Model has not been trained yet, called train() first');\n                }\n                return [2 /*return*/, _super.prototype.predict.call(this, image, flipped)];\n            });\n        });\n    };\n    /**\n     * Classify an input image / Tensor with your trained model. Return topK results\n     * @param image the input image / Tensor to classify against your model\n     * @param maxPredictions how many of the top results do you want? defautls to 3\n     * @param flipped whether to flip an image\n     */\n    TeachableMobileNet.prototype.predictTopK = function (image, maxPredictions, flipped) {\n        if (maxPredictions === void 0) { maxPredictions = 10; }\n        if (flipped === void 0) { flipped = false; }\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (!this.model) {\n                    throw new Error('Model has not been trained yet, called train() first');\n                }\n                return [2 /*return*/, _super.prototype.predictTopK.call(this, image, maxPredictions, flipped)];\n            });\n        });\n    };\n    /**\n     * process the current examples provided to calculate labels and format\n     * into proper tf.data.Dataset\n     */\n    TeachableMobileNet.prototype.prepare = function () {\n        for (var classes in this.examples) {\n            if (classes.length === 0) {\n                throw new Error('Add some examples before training');\n            }\n        }\n        var datasets = this.convertToTfDataset();\n        this.trainDataset = datasets.trainDataset;\n        this.validationDataset = datasets.validationDataset;\n    };\n    /**\n     * Process the examples by first shuffling randomly per class, then adding\n     * one-hot labels, then splitting into training/validation datsets, and finally\n     * sorting one last time\n     */\n    TeachableMobileNet.prototype.convertToTfDataset = function () {\n        // first shuffle each class individually\n        // TODO: we could basically replicate this by insterting randomly\n        for (var i = 0; i < this.examples.length; i++) {\n            this.examples[i] = fisherYates(this.examples[i], this.seed);\n        }\n        // then break into validation and test datasets\n        var trainDataset = [];\n        var validationDataset = [];\n        var _loop_1 = function (i) {\n            var y = flatOneHot(i, this_1.numClasses);\n            var classLength = this_1.examples[i].length;\n            var numValidation = Math.ceil(VALIDATION_FRACTION * classLength);\n            var numTrain = classLength - numValidation;\n            var classTrain = this_1.examples[i].slice(0, numTrain).map(function (dataArray) {\n                return { data: dataArray, label: y };\n            });\n            var classValidation = this_1.examples[i].slice(numTrain).map(function (dataArray) {\n                return { data: dataArray, label: y };\n            });\n            trainDataset = trainDataset.concat(classTrain);\n            validationDataset = validationDataset.concat(classValidation);\n        };\n        var this_1 = this;\n        // for each class, add samples to train and validation dataset\n        for (var i = 0; i < this.examples.length; i++) {\n            _loop_1(i);\n        }\n        // finally shuffle both train and validation datasets\n        trainDataset = fisherYates(trainDataset, this.seed);\n        validationDataset = fisherYates(validationDataset, this.seed);\n        var trainX = tf.data.array(trainDataset.map(function (sample) { return sample.data; }));\n        var validationX = tf.data.array(validationDataset.map(function (sample) { return sample.data; }));\n        var trainY = tf.data.array(trainDataset.map(function (sample) { return sample.label; }));\n        var validationY = tf.data.array(validationDataset.map(function (sample) { return sample.label; }));\n        // return tf.data dataset objects\n        return {\n            trainDataset: tf.data.zip({ xs: trainX, ys: trainY }),\n            validationDataset: tf.data.zip({ xs: validationX, ys: validationY })\n        };\n    };\n    /**\n     * Saving `model`'s topology and weights as two files\n     * (`my-model-1.json` and `my-model-1.weights.bin`) as well as\n     * a `metadata.json` file containing metadata such as text labels to be\n     * downloaded from browser.\n     * @param handlerOrURL An instance of `IOHandler` or a URL-like,\n     * scheme-based string shortcut for `IOHandler`.\n     * @param config Options for saving the model.\n     * @returns A `Promise` of `SaveResult`, which summarizes the result of\n     * the saving, such as byte sizes of the saved artifacts for the model's\n     *   topology and weight values.\n     */\n    TeachableMobileNet.prototype.save = function (handlerOrURL, config) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.model.save(handlerOrURL, config)];\n            });\n        });\n    };\n    /**\n     * Train your data into a new model and join it with mobilenet\n     * @param params the parameters for the model / training\n     * @param callbacks provide callbacks to receive training events\n     */\n    TeachableMobileNet.prototype.train = function (params, callbacks) {\n        if (callbacks === void 0) { callbacks = {}; }\n        return __awaiter(this, void 0, void 0, function () {\n            var originalOnTrainEnd, numLabels, inputShape, inputSize, varianceScaling, optimizer, trainData, validationData, history, jointModel;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        originalOnTrainEnd = callbacks.onTrainEnd || (function () { });\n                        callbacks.onTrainEnd = function (logs) {\n                            if (_this.__stopTrainingResolve) {\n                                _this.__stopTrainingResolve();\n                                _this.__stopTrainingResolve = null;\n                            }\n                            originalOnTrainEnd(logs);\n                        };\n                        // Rest of trian function\n                        if (!this.isPrepared) {\n                            this.prepare();\n                        }\n                        numLabels = this.getLabels().length;\n                        tfjs_1.util.assert(numLabels === this.numClasses, function () { return \"Can not train, has \" + numLabels + \" labels and \" + _this.numClasses + \" classes\"; });\n                        inputShape = this.truncatedModel.outputs[0].shape.slice(1);\n                        inputSize = tf.util.sizeFromShape(inputShape);\n                        if (this.seed) {\n                            varianceScaling = tf.initializers.varianceScaling({ seed: 3.14 });\n                        }\n                        else {\n                            varianceScaling = tf.initializers.varianceScaling({});\n                        }\n                        this.trainingModel = tf.sequential({\n                            layers: [\n                                tf.layers.dense({\n                                    inputShape: [inputSize],\n                                    units: params.denseUnits,\n                                    activation: 'relu',\n                                    kernelInitializer: varianceScaling,\n                                    useBias: true\n                                }),\n                                tf.layers.dense({\n                                    kernelInitializer: varianceScaling,\n                                    useBias: false,\n                                    activation: 'softmax',\n                                    units: this.numClasses\n                                })\n                            ]\n                        });\n                        optimizer = tf.train.adam(params.learningRate);\n                        // const optimizer = tf.train.rmsprop(params.learningRate);\n                        this.trainingModel.compile({\n                            optimizer: optimizer,\n                            // loss: 'binaryCrossentropy',\n                            loss: 'categoricalCrossentropy',\n                            metrics: ['accuracy']\n                        });\n                        if (!(params.batchSize > 0)) {\n                            throw new Error(\"Batch size is 0 or NaN. Please choose a non-zero fraction\");\n                        }\n                        trainData = this.trainDataset.batch(params.batchSize);\n                        validationData = this.validationDataset.batch(params.batchSize);\n                        return [4 /*yield*/, this.trainingModel.fitDataset(trainData, {\n                                epochs: params.epochs,\n                                validationData: validationData,\n                                callbacks: callbacks\n                            })];\n                    case 1:\n                        history = _a.sent();\n                        jointModel = tf.sequential();\n                        jointModel.add(this.truncatedModel);\n                        jointModel.add(this.trainingModel);\n                        this.model = jointModel;\n                        optimizer.dispose(); // cleanup of memory\n                        return [2 /*return*/, this.model];\n                }\n            });\n        });\n    };\n    /*\n     * Setup the exampls array to hold samples per class\n     */\n    TeachableMobileNet.prototype.prepareDataset = function () {\n        for (var i = 0; i < this.numClasses; i++) {\n            this.examples[i] = [];\n        }\n    };\n    TeachableMobileNet.prototype.setLabel = function (index, label) {\n        this._metadata.labels[index] = label;\n    };\n    TeachableMobileNet.prototype.setLabels = function (labels) {\n        this._metadata.labels = labels;\n        this.prepareDataset();\n    };\n    TeachableMobileNet.prototype.getLabel = function (index) {\n        return this._metadata.labels[index];\n    };\n    TeachableMobileNet.prototype.getLabels = function () {\n        return this._metadata.labels;\n    };\n    TeachableMobileNet.prototype.setName = function (name) {\n        this._metadata.modelName = name;\n    };\n    TeachableMobileNet.prototype.getName = function () {\n        return this._metadata.modelName;\n    };\n    TeachableMobileNet.prototype.stopTraining = function () {\n        var _this = this;\n        var promise = new Promise(function (resolve, reject) {\n            _this.trainingModel.stopTraining = true;\n            _this.__stopTrainingResolve = resolve;\n            // this.__stopTrainingReject = reject;\n        });\n        return promise;\n    };\n    TeachableMobileNet.prototype.dispose = function () {\n        this.trainingModel.dispose();\n        _super.prototype.dispose.call(this);\n    };\n    /*\n     * Calculate each class accuracy using the validation dataset\n     */\n    TeachableMobileNet.prototype.calculateAccuracyPerClass = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var validationXs, validationYs, batchSize, iterations, batchesX, batchesY, itX, itY, allX, allY, i, batchedXTensor, batchedXPredictionTensor, argMaxX, batchedYTensor, argMaxY, reference, predictions, i;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        validationXs = this.validationDataset.mapAsync(function (dataset) { return __awaiter(_this, void 0, void 0, function () {\n                            return __generator(this, function (_a) {\n                                return [2 /*return*/, dataset.xs];\n                            });\n                        }); });\n                        validationYs = this.validationDataset.mapAsync(function (dataset) { return __awaiter(_this, void 0, void 0, function () {\n                            return __generator(this, function (_a) {\n                                return [2 /*return*/, dataset.ys];\n                            });\n                        }); });\n                        batchSize = Math.min(validationYs.size, 32);\n                        iterations = Math.ceil(validationYs.size / batchSize);\n                        batchesX = validationXs.batch(batchSize);\n                        batchesY = validationYs.batch(batchSize);\n                        return [4 /*yield*/, batchesX.iterator()];\n                    case 1:\n                        itX = _a.sent();\n                        return [4 /*yield*/, batchesY.iterator()];\n                    case 2:\n                        itY = _a.sent();\n                        allX = [];\n                        allY = [];\n                        i = 0;\n                        _a.label = 3;\n                    case 3:\n                        if (!(i < iterations)) return [3 /*break*/, 7];\n                        return [4 /*yield*/, itX.next()];\n                    case 4:\n                        batchedXTensor = _a.sent();\n                        batchedXPredictionTensor = this.trainingModel.predict(batchedXTensor.value);\n                        argMaxX = batchedXPredictionTensor.argMax(1);\n                        allX.push(argMaxX);\n                        return [4 /*yield*/, itY.next()];\n                    case 5:\n                        batchedYTensor = _a.sent();\n                        argMaxY = batchedYTensor.value.argMax(1);\n                        allY.push(argMaxY);\n                        // 3. dispose of all our tensors\n                        batchedXTensor.value.dispose();\n                        batchedXPredictionTensor.dispose();\n                        batchedYTensor.value.dispose();\n                        _a.label = 6;\n                    case 6:\n                        i++;\n                        return [3 /*break*/, 3];\n                    case 7:\n                        reference = tf.concat(allY);\n                        predictions = tf.concat(allX);\n                        // only if we concatenated more than one tensor for preference and reference\n                        if (iterations !== 1) {\n                            for (i = 0; i < allX.length; i++) {\n                                allX[i].dispose();\n                                allY[i].dispose();\n                            }\n                        }\n                        return [2 /*return*/, { reference: reference, predictions: predictions }];\n                }\n            });\n        });\n    };\n    /*\n     * optional seed for predictable shuffling of dataset\n     */\n    TeachableMobileNet.prototype.setSeed = function (seed) {\n        this.seed = seedrandom(seed);\n    };\n    return TeachableMobileNet;\n}(custom_mobilenet_1.CustomMobileNet));\nexports.TeachableMobileNet = TeachableMobileNet;\nfunction createTeachable(metadata, modelOptions) {\n    return __awaiter(this, void 0, void 0, function () {\n        var mobilenet;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, custom_mobilenet_1.loadTruncatedMobileNet(modelOptions)];\n                case 1:\n                    mobilenet = _a.sent();\n                    return [2 /*return*/, new TeachableMobileNet(mobilenet, metadata)];\n            }\n        });\n    });\n}\nexports.createTeachable = createTeachable;\n"},"sourceMaps":{"js":{"version":3,"file":"teachable-mobilenet.js","sourceRoot":"","sources":["../src/teachable-mobilenet.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs';\nimport { util, Rank } from '@tensorflow/tfjs';\nimport { capture } from './utils/tf';\nimport { TensorContainer } from '@tensorflow/tfjs-core/dist/tensor_types';\nimport { CustomCallbackArgs } from '@tensorflow/tfjs';\nimport { CustomMobileNet,\n    Metadata,\n    loadTruncatedMobileNet,\n    ClassifierInputSource,\n    ModelOptions\n} from './custom-mobilenet';\nimport * as seedrandom from 'seedrandom';\nimport { Initializer } from '@tensorflow/tfjs-layers/dist/initializers';\n\nconst VALIDATION_FRACTION = 0.15;\n\nexport interface TrainingParameters {\n    denseUnits: number;\n    epochs: number;\n    learningRate: number;\n    batchSize: number;\n}\n\ninterface Sample {\n    data: Float32Array;\n    label: number[];\n}\n\n// tslint:disable-next-line:no-any\nconst isTensor = (c: any): c is tf.Tensor =>\n    typeof c.dataId === 'object' && c.shape === 'object';\n\n/**\n * Converts an integer into its one-hot representation and returns\n * the data as a JS Array.\n */\nfunction flatOneHot(label: number, numClasses: number) {\n    const labelOneHot = new Array(numClasses).fill(0) as number[];\n    labelOneHot[label] = 1;\n\n    return labelOneHot;\n}\n\n/**\n * Shuffle an array of Float32Array or Samples using Fisher-Yates algorithm\n * Takes an optional seed value to make shuffling predictable\n */\nfunction fisherYates(array: Float32Array[] | Sample[], seed?: seedrandom.prng) {\n    const length = array.length;\n\n    // need to clone array or we'd be editing original as we goo\n    const shuffled = array.slice();\n\n    for (let i = (length - 1); i > 0; i -= 1) {\n        let randomIndex ;\n        if (seed) {\n            randomIndex = Math.floor(seed() * (i + 1));\n        }\n        else {\n            randomIndex = Math.floor(Math.random() * (i + 1));\n        }\n\n        [shuffled[i], shuffled[randomIndex]] = [shuffled[randomIndex],shuffled[i]];\n    }\n\n    return shuffled;\n}\n\nexport class TeachableMobileNet extends CustomMobileNet {\n    /**\n     * the training model for transfer learning\n     */\n    protected trainingModel: tf.LayersModel;\n\n    /**\n     * Training and validation datasets\n     */\n    private trainDataset: tf.data.Dataset<TensorContainer>;\n    private validationDataset: tf.data.Dataset<TensorContainer>;\n\n    private __stopTrainingResolve: () => void;\n    // private __stopTrainingReject: (error: Error) => void;\n\n    // Number of total samples\n    private totalSamples = 0;\n\n    // Array of all the examples collected\n    public examples: Float32Array[][] = [];\n\n    // Optional seed to make shuffling of data predictable\n    private seed: seedrandom.prng;\n\n    constructor(truncated: tf.LayersModel, metadata: Partial<Metadata>) {\n        super(tf.sequential(), metadata);\n        // the provided model is the truncated mobilenet\n        this.truncatedModel = truncated;\n    }\n\n    public get asSequentialModel() {\n        return this.model as tf.Sequential;\n    }\n\n\n    /**\n     * has the teachable model been trained?\n     */\n    public get isTrained() {\n        return !!this.model && this.model.layers && this.model.layers.length > 2;\n    }\n\n    /**\n     * has the dataset been prepared with all labels and samples processed?\n     */\n    public get isPrepared() {\n        return !!this.trainDataset;\n    }\n\n    /**\n     * how many classes are in the dataset?\n     */\n    public get numClasses(): number {\n        return this._metadata.labels.length;\n    }\n\n    /**\n     * Add a sample of data under the provided className\n     * @param className the classification this example belongs to\n     * @param sample the image / tensor that belongs in this classification\n     */\n    // public async addExample(className: number, sample: HTMLCanvasElement | tf.Tensor) {\n    public async addExample(className: number, sample: HTMLImageElement | HTMLCanvasElement | tf.Tensor) {\n        const cap = isTensor(sample) ? sample : capture(sample);\n        const example = this.truncatedModel.predict(cap) as tf.Tensor;\n\n        const activation = example.dataSync() as Float32Array;\n        cap.dispose();\n        example.dispose();\n\n        // save samples of each class separately\n        this.examples[className].push(activation);\n\n        // increase our sample counter\n        this.totalSamples++;\n    }\n\n    /**\n     * Classify an input image / Tensor with your trained model. Return all results.\n     * @param image the input image / Tensor to classify against your model\n     * @param topK how many of the top results do you want? defautls to 3\n     */\n    public async predict(image: ClassifierInputSource, flipped = false) {\n        if (!this.model) {\n            throw new Error('Model has not been trained yet, called train() first');\n        }\n        return super.predict(image, flipped);\n    }\n\n    /**\n     * Classify an input image / Tensor with your trained model. Return topK results\n     * @param image the input image / Tensor to classify against your model\n     * @param maxPredictions how many of the top results do you want? defautls to 3\n     * @param flipped whether to flip an image\n     */\n    public async predictTopK(image: ClassifierInputSource, maxPredictions = 10, flipped = false, ) {\n        if (!this.model) {\n            throw new Error('Model has not been trained yet, called train() first');\n        }\n        return super.predictTopK(image, maxPredictions, flipped);\n    }\n\n    /**\n     * process the current examples provided to calculate labels and format\n     * into proper tf.data.Dataset\n     */\n    public prepare() {\n        for (const classes in this.examples){\n            if (classes.length === 0) {\n                throw new Error('Add some examples before training');\n            }\n        }\n\n        const datasets = this.convertToTfDataset();\n        this.trainDataset = datasets.trainDataset;\n        this.validationDataset = datasets.validationDataset;\n    }\n\n    /**\n     * Process the examples by first shuffling randomly per class, then adding\n     * one-hot labels, then splitting into training/validation datsets, and finally\n     * sorting one last time\n     */\n    private convertToTfDataset() {\n        // first shuffle each class individually\n        // TODO: we could basically replicate this by insterting randomly\n        for (let i = 0; i < this.examples.length; i++) {\n            this.examples[i] = fisherYates(this.examples[i], this.seed) as Float32Array[];\n        }\n\n        // then break into validation and test datasets\n\n        let trainDataset: Sample[] = [];\n        let validationDataset: Sample[] = [];\n\n        // for each class, add samples to train and validation dataset\n        for (let i = 0; i < this.examples.length; i++) {\n            const y = flatOneHot(i, this.numClasses);\n\n            const classLength = this.examples[i].length;\n            const numValidation = Math.ceil(VALIDATION_FRACTION * classLength);\n            const numTrain = classLength - numValidation;\n\n            const classTrain = this.examples[i].slice(0, numTrain).map((dataArray) => {\n                return { data: dataArray, label: y };\n            });\n\n            const classValidation = this.examples[i].slice(numTrain).map((dataArray) => {\n                return { data: dataArray, label: y };\n            });\n\n            trainDataset = trainDataset.concat(classTrain);\n            validationDataset = validationDataset.concat(classValidation);\n        }\n\n        // finally shuffle both train and validation datasets\n        trainDataset = fisherYates(trainDataset, this.seed) as Sample[];\n        validationDataset = fisherYates(validationDataset, this.seed) as Sample[];\n\n        const trainX = tf.data.array(trainDataset.map(sample => sample.data));\n        const validationX = tf.data.array(validationDataset.map(sample => sample.data));\n        const trainY = tf.data.array(trainDataset.map(sample => sample.label));\n        const validationY = tf.data.array(validationDataset.map(sample => sample.label));\n\n        // return tf.data dataset objects\n        return {\n            trainDataset: tf.data.zip({ xs: trainX,  ys: trainY}),\n            validationDataset: tf.data.zip({ xs: validationX,  ys: validationY})\n        };\n    }\n\n    /**\n     * Saving `model`'s topology and weights as two files\n     * (`my-model-1.json` and `my-model-1.weights.bin`) as well as\n     * a `metadata.json` file containing metadata such as text labels to be\n     * downloaded from browser.\n     * @param handlerOrURL An instance of `IOHandler` or a URL-like,\n     * scheme-based string shortcut for `IOHandler`.\n     * @param config Options for saving the model.\n     * @returns A `Promise` of `SaveResult`, which summarizes the result of\n     * the saving, such as byte sizes of the saved artifacts for the model's\n     *   topology and weight values.\n     */\n    public async save(handlerOrURL: tf.io.IOHandler | string, config?: tf.io.SaveConfig): Promise<tf.io.SaveResult> {\n        return this.model.save(handlerOrURL, config);\n    }\n\n    /**\n     * Train your data into a new model and join it with mobilenet\n     * @param params the parameters for the model / training\n     * @param callbacks provide callbacks to receive training events\n     */\n    public async train(params: TrainingParameters, callbacks: CustomCallbackArgs = {}) {\n        // Add callback for onTrainEnd in case of early stop\n        const originalOnTrainEnd = callbacks.onTrainEnd || (() => {});\n        callbacks.onTrainEnd = (logs: tf.Logs) => {\n            if (this.__stopTrainingResolve) {\n                this.__stopTrainingResolve();\n                this.__stopTrainingResolve = null;\n            }\n            originalOnTrainEnd(logs);\n        };\n        \n        // Rest of trian function\n        if (!this.isPrepared) {\n            this.prepare();\n        }\n\n        const numLabels = this.getLabels().length;\n        util.assert(\n            numLabels === this.numClasses,\n            () => `Can not train, has ${numLabels} labels and ${this.numClasses} classes`);\n\n        const inputShape = this.truncatedModel.outputs[0].shape.slice(1); // [ 7 x 7 x 1280]\n        const inputSize = tf.util.sizeFromShape(inputShape);\n\n        // in case we need to use a seed for predictable training\n        let varianceScaling: Initializer;\n        if (this.seed) {\n            varianceScaling = tf.initializers.varianceScaling({ seed: 3.14});\n        }\n        else {\n            varianceScaling = tf.initializers.varianceScaling({});\n        }\n\n        this.trainingModel = tf.sequential({\n            layers: [\n                tf.layers.dense({\n                    inputShape: [inputSize],\n                    units: params.denseUnits,\n                    activation: 'relu',\n                    kernelInitializer: varianceScaling, // 'varianceScaling'\n                    useBias: true\n                }),\n                tf.layers.dense({\n                    kernelInitializer: varianceScaling, // 'varianceScaling'\n                    useBias: false,\n                    activation: 'softmax',\n                    units: this.numClasses\n                })\n            ]\n        });\n\n        const optimizer = tf.train.adam(params.learningRate);\n        // const optimizer = tf.train.rmsprop(params.learningRate);\n\n        this.trainingModel.compile({\n            optimizer,\n            // loss: 'binaryCrossentropy',\n            loss: 'categoricalCrossentropy',\n            metrics: ['accuracy']\n        });\n\n        if (!(params.batchSize > 0)) {\n            throw new Error(\n            `Batch size is 0 or NaN. Please choose a non-zero fraction`\n            );\n        }\n\n        const trainData = this.trainDataset.batch(params.batchSize);\n        const validationData = this.validationDataset.batch(params.batchSize);\n\n        // For debugging: check for shuffle or result from trainDataset\n        /*\n        await trainDataset.forEach((e: tf.Tensor[]) => {\n            console.log(e);\n        })\n        */\n\n        const history = await this.trainingModel.fitDataset(trainData, {\n            epochs: params.epochs,\n            validationData,\n            callbacks\n        });\n\n        const jointModel = tf.sequential();\n        jointModel.add(this.truncatedModel);\n        jointModel.add(this.trainingModel);\n        this.model = jointModel;\n\n        optimizer.dispose(); // cleanup of memory\n\n        return this.model;\n    }\n\n    /*\n     * Setup the exampls array to hold samples per class\n     */\n    public prepareDataset() {\n        for (let i = 0; i < this.numClasses; i++) {\n            this.examples[i] = [];\n        }\n    }\n\n    public setLabel(index: number, label: string) {\n        this._metadata.labels[index] = label;\n    }\n\n    public setLabels(labels: string[]) {\n        this._metadata.labels = labels;\n        this.prepareDataset();\n    }\n\n    public getLabel(index: number) {\n        return this._metadata.labels[index];\n    }\n\n    public getLabels() {\n        return this._metadata.labels;\n    }\n\n    public setName(name: string) {\n        this._metadata.modelName = name;\n    }\n\n    public getName() {\n        return this._metadata.modelName;\n    }\n\n    public stopTraining() {  \n        const promise = new Promise((resolve, reject) => {\n            this.trainingModel.stopTraining = true;\n            this.__stopTrainingResolve = resolve;\n            // this.__stopTrainingReject = reject;\n        });\n        \n        return promise;\n    }\n\n    public dispose() {\n        this.trainingModel.dispose();\n        super.dispose();\n    }\n\n    /* \n     * Calculate each class accuracy using the validation dataset\n     */\n    public async calculateAccuracyPerClass() {\n        const validationXs = this.validationDataset.mapAsync(async (dataset: TensorContainer) => {\n            return (dataset as { xs: TensorContainer, ys: TensorContainer}).xs;\n        });\n        const validationYs = this.validationDataset.mapAsync(async (dataset: TensorContainer) => {\n            return (dataset as { xs: TensorContainer, ys: TensorContainer}).ys;\n        });\n\n        // we need to split our validation data into batches in case it is too large to fit in memory\n        const batchSize = Math.min(validationYs.size, 32);\n        const iterations = Math.ceil(validationYs.size / batchSize);\n\n        const batchesX = validationXs.batch(batchSize);\n        const batchesY = validationYs.batch(batchSize);\n        const itX = await batchesX.iterator();\n        const itY = await batchesY.iterator();\n        const allX = [];\n        const allY = [];\n\n        for (let i = 0; i < iterations; i++) {\n            // 1. get the prediction values in batches\n            const batchedXTensor = await itX.next();\n            const batchedXPredictionTensor = this.trainingModel.predict(batchedXTensor.value) as tf.Tensor;\n            const argMaxX = batchedXPredictionTensor.argMax(1); // Returns the indices of the max values along an axis\n            allX.push(argMaxX);\n\n            // 2. get the ground truth label values in batches\n            const batchedYTensor = await itY.next();\n            const argMaxY = batchedYTensor.value.argMax(1); // Returns the indices of the max values along an axis\n            allY.push(argMaxY);\n\n            // 3. dispose of all our tensors\n            batchedXTensor.value.dispose();\n            batchedXPredictionTensor.dispose();\n            batchedYTensor.value.dispose();\n        }\n\n        // concatenate all the results of the batches\n        const reference = tf.concat(allY); // this is the ground truth\n        const predictions = tf.concat(allX); // this is the prediction our model is guessing\n\n        // only if we concatenated more than one tensor for preference and reference\n        if (iterations !== 1) {\n            for (let i = 0; i < allX.length; i++) {\n                allX[i].dispose();\n                allY[i].dispose();\n            }\n        }\n\n        return { reference, predictions };\n    }\n\n    /*\n     * optional seed for predictable shuffling of dataset\n     */\n    public setSeed(seed: string) {\n        this.seed = seedrandom(seed);\n    }\n}\n\nexport async function createTeachable(metadata: Partial<Metadata>, modelOptions?: ModelOptions) {\n    const mobilenet = await loadTruncatedMobileNet(modelOptions);\n    return new TeachableMobileNet(mobilenet, metadata);\n}\n"]}},"error":null,"hash":"63e7b5287cfd0c76be7047dc81aaa4af","cacheData":{"env":{}}}